<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Swap ETH for TORC</title>
    <!-- Preload Google Fonts for smooth typography -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- Ethers.js library for interacting with Ethereum wallets -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.8.0/ethers.umd.min.js" type="application/javascript"></script>
    <style>
        /*
          Colour palette and typographic variables. Defining these at the top makes
          it trivial to experiment with different schemes later on. The dark
          background contrasts sharply with the orange highlight used throughout
          the site and helps the card pop off the page.
        */
        :root {
            --primary-color: #ff7a27;
            --secondary-color: #0f1a2a;
            --overlay-colour: rgba(10, 9, 33, 0.65);
            --text-light: #ffffff;
            --text-muted: #a9acc9;
            --accent-blue: #3c82ff;
            --button-blue: #2762f3;
            --button-blue-hover: #3c78f8;
        }

        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: 'Montserrat', sans-serif;
            color: var(--text-light);
        }

        /*
          The swirling nebula background generated with the image tool. A dark
          overlay is layered on top to improve contrast for text and cards.
        */
        body {
            background: url('396baa0b-e828-47a1-8240-6a3cbd155fab.png') no-repeat center/cover fixed;
            position: relative;
        }
        body::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--overlay-colour);
            z-index: -1;
        }

        /* Navigation bar styling */
        .navbar {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 2rem;
            box-sizing: border-box;
            position: relative;
            z-index: 5;
        }
        .logo {
            font-size: 2rem;
            font-weight: 700;
            color: var(--accent-blue);
            text-transform: lowercase;
        }
        .nav-links {
            list-style: none;
            display: flex;
            gap: 1.5rem;
            margin: 0;
            padding: 0;
        }
        .nav-links a {
            text-decoration: none;
            color: var(--text-light);
            font-weight: 500;
            transition: color 0.3s ease;
        }
        .nav-links a:hover {
            color: var(--primary-color);
        }
        .nav-actions {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        .btn-buy {
            background: var(--primary-color);
            border: none;
            padding: 0.6rem 1.3rem;
            border-radius: 8px;
            color: #fff;
            font-weight: 600;
            cursor: pointer;
            transition: opacity 0.3s ease;
        }
        .btn-buy:hover {
            opacity: 0.85;
        }

        /* Hero section layout */
        .hero {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: flex-start;
            padding: 5rem 8% 3rem;
            min-height: 90vh;
            box-sizing: border-box;
        }
        .hero-text {
            flex: 1 1 45%;
            max-width: 50%;
            padding-right: 2rem;
        }
        .hero-text h1 {
            font-size: 2.6rem;
            line-height: 1.35;
            margin: 0;
        }
        .hero-text h1 em {
            font-style: italic;
            color: var(--primary-color);
        }
        .hero-text p {
            font-size: 1rem;
            margin-top: 1.2rem;
            color: var(--text-muted);
        }

        /* Swap card styling */
        .swap-card {
            width: 380px;
            background: var(--secondary-color);
            padding: 1.5rem;
            border-radius: 20px;
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.45);
        }
        .card-tagline {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-bottom: 0.4rem;
            text-transform: uppercase;
            letter-spacing: 0.04em;
        }
        .tabs {
            display: flex;
            margin-bottom: 1.1rem;
        }
        .tab {
            flex: 1;
            text-align: center;
            padding: 0.6rem 0;
            cursor: pointer;
            border-radius: 8px;
            background: #182448;
            color: var(--text-light);
            font-weight: 600;
            user-select: none;
        }
        .tab.active {
            background: var(--primary-color);
            color: #fff;
        }
        .form-row {
            margin-bottom: 1rem;
        }
        .form-row label {
            display: block;
            font-size: 0.8rem;
            margin-bottom: 0.4rem;
            color: var(--text-muted);
        }
        .form-row input {
            width: 100%;
            padding: 0.6rem;
            border-radius: 8px;
            border: none;
            background: #131b35;
            color: var(--text-light);
            font-size: 1rem;
        }
        .button-row {
            display: flex;
            justify-content: space-between;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        .button-row button {
            flex: 1;
            padding: 0.6rem 0;
            border: none;
            background: #131b35;
            color: var(--text-light);
            border-radius: 8px;
            font-size: 0.9rem;
            cursor: pointer;
        }
        .button-row button:disabled {
            opacity: 0.5;
            cursor: default;
        }
        #connectWallet, #getQuote, #buyTorc {
            width: 100%;
            padding: 0.7rem 0;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            margin-bottom: 0.5rem;
        }
        #connectWallet {
            background: var(--button-blue);
            color: #fff;
        }
        #connectWallet:hover {
            background: var(--button-blue-hover);
        }
        #getQuote {
            background: #252c4c;
            color: var(--text-light);
        }
        #buyTorc {
            background: var(--primary-color);
            color: #fff;
        }
        /* Dual input layout for ETH and TORC */
        .dual-inputs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.6rem;
        }
        .input-field {
            flex: 1 1 50%;
            min-width: 0;
        }
        .input-with-icon {
            position: relative;
        }
        .input-with-icon input {
            width: 100%;
            padding: 0.6rem;
            border-radius: 8px;
            border: none;
            background: #131b35;
            color: var(--text-light);
            font-size: 1rem;
            padding-right: 2.2rem;
        }
        .input-with-icon .icon {
            position: absolute;
            right: 0.8rem;
            top: 50%;
            transform: translateY(-50%);
            font-size: 1rem;
            pointer-events: none;
        }
        .input-with-icon .icon.eth {
            color: #4ea8ff;
        }
        .input-with-icon .icon.torc {
            color: #e4b14f;
        }
        .or-text {
            text-align: center;
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-bottom: 0.7rem;
        }
        /* Status and info outputs */
        #quoteDetails, #transactionStatus, #swapDetails, #walletInfo {
            font-size: 0.8rem;
            margin-top: 0.5rem;
            color: var(--text-muted);
            word-wrap: break-word;
        }
        .quote-details {
            font-size: 0.8rem;
            margin-bottom: 0.5rem;
            color: var(--text-muted);
            word-wrap: break-word;
        }
        .whitepaper-btn {
            display: inline-block;
            margin-top: 1.2rem;
            background: var(--primary-color);
            color: #fff;
            padding: 0.6rem 1.2rem;
            border-radius: 8px;
            font-size: 0.9rem;
            text-decoration: none;
            font-weight: 600;
            transition: opacity 0.3s ease;
        }
        .whitepaper-btn:hover {
            opacity: 0.85;
        }

        /* Responsive tweaks */
        @media (max-width: 900px) {
            .hero {
                flex-direction: column;
                align-items: stretch;
            }
            .hero-text {
                max-width: 100%;
                padding-right: 0;
                margin-bottom: 2.5rem;
            }
            .swap-card {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <nav class="navbar">
        <div class="logo">torc</div>
        <ul class="nav-links">
            <li><a href="#">WHAT’S TORC?</a></li>
            <li><a href="#">ANCIENT QUEST</a></li>
            <li><a href="#">WHITE PAPER</a></li>
            <li><a href="#">FAQS</a></li>
        </ul>
        <div class="nav-actions">
            <button class="btn-buy">Buy Now</button>
        </div>
    </nav>

    <section class="hero">
        <div class="hero-text">
            <h1>Being human is a big job.<br>Being <em>well</em> is an epic quest.</h1>
            <p>A trailblazing twist on an ancient hunt</p>
        </div>
        <div class="swap-card">
            <div class="card-tagline">Trade on timeless wisdom</div>
            <div class="tabs">
                <div class="tab active">Buy TORC</div>
                <div class="tab">Info</div>
            </div>
            <!--
              Two inputs: one for ETH and one for TORC. Each input includes a small
              icon aligned to the right to hint at the currency. When the user
              enters a value in one field, the other field updates instantly via
              the JavaScript logic appended below. This replicates the look of
              the reference design where two boxes sit side-by-side.
            -->
            <div class="dual-inputs">
                <div class="input-field">
                    <label for="ethAmount">ETH you pay</label>
                    <div class="input-with-icon">
                        <input id="ethAmount" type="text" placeholder="0.0001" onfocus="if(this.value==''){this.value='';}" onblur="if(this.value==''){this.value='';}">
                        <span class="icon eth">&#x039E;</span>
                    </div>
                </div>
                <div class="input-field">
                    <label for="torcAmount">$ TORC you receive</label>
                    <div class="input-with-icon">
                        <input id="torcAmount" type="text" placeholder="0" onfocus="if(this.value==''){this.value='';}" onblur="if(this.value==''){this.value='';}">
                        <span class="icon torc">&#x25CF;</span>
                    </div>
                </div>
            </div>
            <!-- Display live quote just below the input boxes -->
            <div id="quoteDetails" class="quote-details"></div>
            <div class="or-text">or choose a dollar amount</div>
            <div class="button-row">
                <button id="set50" onclick="setEthAmount(50)" disabled>$50</button>
                <button id="set100" onclick="setEthAmount(100)" disabled>$100</button>
                <button id="set500" onclick="setEthAmount(500)" disabled>$500</button>
            </div>
            <button id="connectWallet">Connect Wallet</button>
            <button id="getQuote" disabled>Get Quote</button>
            <button id="buyTorc" disabled>Buy TORC</button>
            <div id="walletInfo"></div>
            <div id="transactionStatus"></div>
            <div id="swapDetails"></div>
            <a class="whitepaper-btn" href="#">WHITE PAPER</a>
        </div>
    </section>

    <script>
        // Preserve the original JavaScript functionality. The markup above retains
        // the same element IDs so existing logic continues to work unchanged.
    let signer;
    let routerContract;
    let pairContract;
    let ethPriceUSD;
    let cachedWeth; // cache resolved WETH address
    let routerHealthy = false; // code exists at routerAddress

        // Flag to prevent infinite loops when synchronising the dual inputs.
        let isUpdating = false;

    // Router address (update per network: mainnet UniswapV2 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D)
    const routerAddress = '0xC532a74256D3Db42D0Bf7a0400fEFDbad7694008';
    // Fallback WETH (mainnet) – replace if using another chain
    const FALLBACK_WETH = '0x7b79995e5f793A07Bc00c21412e50Ecae098E7f9';
        const pairAddress = '0x157f2d14104A5cBFf12d47311D86ED53784428c2';
        const tokenAddress = '0x4d83764fbab749d1bd1d1fcb7ead7a6c52a169f9';
        const routerABI = [
            "function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts)",
            "function WETH() external pure returns (address)",
            "function getAmountsOut(uint amountIn, address[] memory path) public view returns (uint[] memory amounts)",
            "function getAmountsIn(uint amountOut, address[] memory path) public view returns (uint[] memory amounts)"
        ];
        const pairABI = [
            "event Swap(address indexed sender, uint amount0In, uint amount1In, uint amount0Out, uint amount1Out, address indexed to)"
        ];
        // Extend pair ABI for reserve-based fallback quoting
        pairABI.push(
            "function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast)",
            "function token0() external view returns (address)",
            "function token1() external view returns (address)"
        );

        // EIP-1193 provider detection with multi-injection support (MetaMask preferred)
        function getInjectedProvider() {
            const { ethereum } = window;
            if (!ethereum) return null;
            if (Array.isArray(ethereum.providers) && ethereum.providers.length > 0) {
                const mm = ethereum.providers.find(p => p.isMetaMask);
                return mm || ethereum.providers[0];
            }
            return ethereum;
        }

        async function enableUI(provider) {
            const ethersProvider = new ethers.providers.Web3Provider(provider, 'any');
            await provider.request({ method: 'eth_requestAccounts' });
            signer = ethersProvider.getSigner();
            const address = await signer.getAddress();
            const balance = await ethersProvider.getBalance(address);
            const balanceInEth = ethers.utils.formatEther(balance);
            document.getElementById('walletInfo').innerHTML = `Connected Wallet Address: ${address}<br>Balance: ${balanceInEth} ETH`;

            routerContract = new ethers.Contract(routerAddress, routerABI, signer);
            pairContract = new ethers.Contract(pairAddress, pairABI, signer);

            // Check router code exists to avoid CALL_EXCEPTION on WETH()
            try {
                const code = await ethersProvider.getCode(routerAddress);
                routerHealthy = code && code !== '0x';
                if (!routerHealthy) {
                    console.warn('No contract code at routerAddress; using fallback WETH and disabling quotes.');
                    document.getElementById('quoteDetails').innerHTML = 'Router unavailable on this network.';
                }
            } catch (e) {
                console.warn('Router code check failed', e);
            }
            document.getElementById('buyTorc').disabled = false;
            document.getElementById('getQuote').disabled = false;
            document.getElementById('set50').disabled = false;
            document.getElementById('set100').disabled = false;
            document.getElementById('set500').disabled = false;

            // Fetch current ETH price (USD)
            try {
                const response = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=ethereum&vs_currencies=usd');
                const data = await response.json();
                ethPriceUSD = data?.ethereum?.usd;
            } catch (e) {
                console.warn('Failed to fetch ETH price:', e);
            }

            // React to account/chain changes
            provider.on?.('accountsChanged', () => window.location.reload());
            provider.on?.('chainChanged', () => window.location.reload());
        }

        document.getElementById('connectWallet').addEventListener('click', async () => {
            try {
                const provider = getInjectedProvider();
                if (!provider) {
                    alert('MetaMask (or an EIP-1193 wallet) is not available. Please install MetaMask and refresh.');
                    return;
                }
                await enableUI(provider);
            } catch (error) {
                console.error('Error connecting to wallet:', error);
                alert('Failed to connect wallet. See console for details.');
            }
        });

        function setEthAmount(usdAmount) {
            const ethAmount = (usdAmount / ethPriceUSD).toFixed(4);
            document.getElementById('ethAmount').value = ethAmount;
            // Trigger quote update whenever preset amounts are used.
            // Only attempt to compute a quote when contracts are loaded.
            if (routerContract) {
                updateFromEth();
            }
        }

        /**
         * Update the TORC amount based on the ETH entered by the user.
         * Utilises getAmountsOut on the router to fetch a live quote for
         * ETH→TORC swaps. Writes the result into the TORC input and the
         * quoteDetails area.
         */
        async function getWethAddress() {
            if (cachedWeth) return cachedWeth;
            if (!routerHealthy) {
                cachedWeth = FALLBACK_WETH;
                return cachedWeth;
            }
            try {
                cachedWeth = await routerContract.WETH();
            } catch (e) {
                console.warn('WETH() call reverted, falling back', e);
                cachedWeth = FALLBACK_WETH;
            }
            return cachedWeth;
        }

        async function updateFromEth() {
            if (isUpdating) return;
            const ethInput = document.getElementById('ethAmount').value.trim();
            // Allow empty / partial numeric ("0." etc.) without throwing
            if (!ethInput) {
                document.getElementById('torcAmount').value = '';
                document.getElementById('quoteDetails').innerHTML = '';
                return;
            }
            if (!/^\d*(?:\.\d*)?$/.test(ethInput)) return; // invalid partial
            isUpdating = true;
            try {
                if (!routerContract) return;
                const amountETH = ethers.utils.parseEther(ethInput === '.' ? '0' : ethInput);
                if (amountETH.isZero()) {
                    document.getElementById('torcAmount').value = '0';
                    document.getElementById('quoteDetails').innerHTML = '';
                } else {
                    const path = [await getWethAddress(), tokenAddress];
                    const quote = await routerContract.getAmountsOut(amountETH, path);
                    const torcOut = ethers.utils.formatUnits(quote[1], 18);
                    document.getElementById('torcAmount').value = torcOut;
                    if (ethPriceUSD) {
                        const ethValueUSD = (parseFloat(ethInput) * ethPriceUSD).toFixed(2);
                        document.getElementById('quoteDetails').innerHTML = `Quote: ${ethInput} ETH ≈ ${torcOut} TORC (≈ $${ethValueUSD} USD)`;
                    }
                }
            } catch (err) {
                console.error('Error updating from ETH:', err);
            } finally {
                isUpdating = false;
            }
        }

        /**
         * Update the ETH amount based on the TORC entered by the user. Uses
         * getAmountsOut in the reverse direction (TORC→ETH) to estimate how
         * much ETH would be returned when swapping the provided TORC amount.
         */
    async function updateFromTorc() {
            if (isUpdating) return;
            const torcInput = document.getElementById('torcAmount').value.trim();
            if (!torcInput) {
                document.getElementById('ethAmount').value = '';
                document.getElementById('quoteDetails').innerHTML = '';
                return;
            }
            if (!/^\d*(?:\.\d*)?$/.test(torcInput)) return; // invalid partial
            isUpdating = true;
            try {
                if (!routerContract) return;
                const amountTorc = ethers.utils.parseUnits(torcInput === '.' ? '0' : torcInput, 18);
                if (amountTorc.isZero()) {
                    document.getElementById('ethAmount').value = '0';
                    document.getElementById('quoteDetails').innerHTML = '';
                } else {
                    // We want the ETH required for desired TORC out => use getAmountsIn
                    const wethAddress = await getWethAddress();
                    const path = [wethAddress, tokenAddress];
                    let ethRequired;
                    try {
                        const amountsIn = await routerContract.getAmountsIn(amountTorc, path);
                        ethRequired = ethers.utils.formatEther(amountsIn[0]);
                    } catch (quoteErr) {
                        console.warn('getAmountsIn reverted; falling back to ratio estimation', quoteErr);
                        ethRequired = await fallbackQuoteEthForTorc(amountTorc, wethAddress);
                    }
                    document.getElementById('ethAmount').value = ethRequired;
                    if (ethPriceUSD) {
                        const ethValueUSD = (parseFloat(ethRequired) * ethPriceUSD).toFixed(2);
                        document.getElementById('quoteDetails').innerHTML = `Quote: ${ethRequired} ETH → ${torcInput} TORC (Cost ≈ $${ethValueUSD} USD)`;
                    }
                }
            } catch (err) {
                console.error('Error updating from TORC:', err);
            } finally {
                isUpdating = false;
            }
        }

        // Fallback: derive ETH required from reserves or a forward small sample quote
        async function fallbackQuoteEthForTorc(amountTorcWei, wethAddress) {
            // Try reserves first
            try {
                if (pairContract) {
                    const [r0, r1] = await pairContract.getReserves();
                    const t0 = await pairContract.token0();
                    const t1 = await pairContract.token1();
                    let reserveWeth; let reserveTorc;
                    if (t0.toLowerCase() === wethAddress.toLowerCase()) {
                        reserveWeth = r0; reserveTorc = r1;
                    } else if (t1.toLowerCase() === wethAddress.toLowerCase()) {
                        reserveWeth = r1; reserveTorc = r0;
                    }
                    if (reserveWeth && reserveTorc && reserveTorc > 0) {
                        // Uniswap invariant: amountIn = (reserveIn * amountOut * 1000) / ((reserveOut - amountOut)*997)
                        // Simplified spot (ignoring fee) fallback if amount small relative to reserves
                        if (amountTorcWei < reserveTorc / 10) {
                            const spotEth = amountTorcWei * reserveWeth / reserveTorc; // integer math ok for approximation
                            return ethers.utils.formatEther(spotEth.toString());
                        }
                    }
                }
            } catch (e) {
                console.warn('Reserve-based fallback failed', e);
            }
            // Secondary: sample 0.01 ETH forward quote then scale
            try {
                const sampleEth = ethers.utils.parseEther('0.01');
                const pathFwd = [wethAddress, tokenAddress];
                const out = await routerContract.getAmountsOut(sampleEth, pathFwd);
                const torcPerEth = parseFloat(ethers.utils.formatUnits(out[1], 18)) / parseFloat(ethers.utils.formatEther(sampleEth));
                if (torcPerEth > 0) {
                    const desiredTorc = parseFloat(ethers.utils.formatUnits(amountTorcWei, 18));
                    const neededEth = desiredTorc / torcPerEth;
                    return neededEth.toFixed(6);
                }
            } catch (e2) {
                console.warn('Sample forward quote fallback failed', e2);
            }
            return '0';
        }

        // Debounce to avoid spamming RPC while typing
        let debounceTimer;
        function debounce(fn) {
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(fn, 250);
        }

        document.getElementById('getQuote').addEventListener('click', async () => {
            // Determine which field has a value and update accordingly. If both
            // fields have values, prioritise the ETH→TORC direction.
            const ethVal = document.getElementById('ethAmount').value;
            const torcVal = document.getElementById('torcAmount').value;
            if (ethVal) {
                await updateFromEth();
            } else if (torcVal) {
                await updateFromTorc();
            } else {
                alert('Please enter an amount of ETH or TORC.');
            }
        });

        document.getElementById('buyTorc').addEventListener('click', async () => {
            try {
                if (!routerContract || !pairContract) {
                    throw new Error("Contracts not initialized. Please connect your wallet first.");
                }
                const wethAddress = await getWethAddress();
                const amountInput = document.getElementById('ethAmount').value;
                const amountETH = ethers.utils.parseEther(amountInput || "0.0001");
                const path = [wethAddress, tokenAddress];
                const to = await signer.getAddress();
                const deadline = Math.floor((new Date()).getTime() / 1000) + 100;
                const tx = await routerContract.swapExactETHForTokens(
                    0,
                    path,
                    to,
                    deadline,
                    { value: amountETH }
                );
                document.getElementById('transactionStatus').innerHTML = `Transaction submitted (Pending): ${tx.hash}`;

                pairContract.once("Swap", (sender, amount0In, amount1In, amount0Out, amount1Out, to, event) => {
                    const ethIn = ethers.utils.formatUnits(amount0In, 18);
                    const torcOut = ethers.utils.formatUnits(amount1Out, 18);
                    document.getElementById('swapDetails').innerHTML = `Swap Details: ${ethIn} ETH swapped for ${torcOut} TORC`;
                });

                await tx.wait();
                document.getElementById('transactionStatus').innerHTML = `Transaction Mined: ${tx.hash}`;
                console.log('Transaction Hash:', tx.hash);
                alert('TORC purchased successfully!');
            } catch (error) {
                console.error('Transaction failed:', error);
                document.getElementById('transactionStatus').innerHTML = `Transaction Failed/Cancelled: ${error.message}`;
                alert('Failed to buy TORC.');
            }
        });

        // Hook up instant quoting on input changes. These listeners call the
        // appropriate update functions when the user types into either field.
        document.getElementById('ethAmount').addEventListener('input', () => {
            if (routerContract) debounce(updateFromEth);
        });
        document.getElementById('torcAmount').addEventListener('input', () => {
            if (routerContract) debounce(updateFromTorc);
        });
    </script>
</body>
</html>